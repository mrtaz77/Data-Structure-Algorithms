{
    "sourceFile": "CPP/Graph/MSTOffline/Prim.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 28,
            "patches": [
                {
                    "date": 1686144939783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1686144965591,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,28 +2,48 @@\n #include\"DisjointSet.h\"\r\n #include\"GraphUtil.h\"\r\n using namespace std;\r\n \r\n-vector<pair<int,pair<int,double>>> kruskalMST(vector<pair<int,double>> adj[],int n,int e){\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n){\r\n     vector<pair<int,pair<int,double>>> mst;\r\n-    DisjointSet set(n);\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n \r\n-    vector<pair<double, pair<int, int>>> edges(e);\r\n-    for (int i = 0; i < n; i++) {\r\n-        for (auto edge : adj[i])edges.push_back({edge.second,{i, edge.first}});\r\n+    int start = 0;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n     }\r\n-    \r\n-    sort(edges.begin(),edges.end());\r\n \r\n-    for(auto e:edges){\r\n-        int u = e.second.first;\r\n-        int v = e.second.second;\r\n-        if (set.findUp(u) != set.findUp(v)) {\r\n-            mst.push_back({u, {v, e.first}});\r\n-            set.Union(u, v);\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n         }\r\n     }\r\n-\r\n     return mst;\r\n }\r\n \r\n double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n"
                },
                {
                    "date": 1686144975850,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n }\r\n \r\n double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n     double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> kruskal_mst = kruskalMST(adj,n,e);\r\n+    vector<pair<int,pair<int,double>>> kruskal_mst = MST(adj,n,e);\r\n \r\n     for(int i = 0; i < kruskal_mst.size(); ++i)cost+=kruskal_mst[i].second.second;\r\n     return cost;\r\n }\r\n"
                },
                {
                    "date": 1686144999147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,89 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    int start = 0;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> kruskal_mst = primMST(adj,n,e);\r\n+\r\n+    for(int i = 0; i < kruskal_mst.size(); ++i)cost+=kruskal_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"kruskal.txt\", \"w\", stdout);\r\n+\r\n+    int n,m;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> kruskal_mst = kruskalMST(adj,n,m);\r\n+\r\n+    cout<<\"Kruskal's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < kruskal_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = kruskal_mst[i].first;\r\n+        v = kruskal_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686145026442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,87 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n+\r\n+    cout<<\"prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686145141048,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,87 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686145666001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    \r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686145671398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    c\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686145677718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686145683147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686145693230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686145721392,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686145729804,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686146949299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,start)<<endl;\r\n+\r\n+    \r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686147865222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,982 +75,13 @@\n     vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n \r\n     cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,start)<<endl;\r\n \r\n-    \r\n     for(int i = 0; i < prim_mst.size(); ++i){\r\n         int u,v,w;\r\n         u = prim_mst[i].first;\r\n         v = prim_mst[i].second.first;\r\n         cout<<u<<\" \"<<v<<endl; \r\n     }\r\n \r\n     delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    c\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    \r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,e);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,m);\r\n-\r\n-    cout<<\"prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    int start = 0;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> kruskal_mst = primMST(adj,n,e);\r\n-\r\n-    for(int i = 0; i < kruskal_mst.size(); ++i)cost+=kruskal_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"kruskal.txt\", \"w\", stdout);\r\n-\r\n-    int n,m;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> kruskal_mst = kruskalMST(adj,n,m);\r\n-\r\n-    cout<<\"Kruskal's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < kruskal_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = kruskal_mst[i].first;\r\n-        v = kruskal_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    int start = 0;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> kruskal_mst = MST(adj,n,e);\r\n-\r\n-    for(int i = 0; i < kruskal_mst.size(); ++i)cost+=kruskal_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"kruskal.txt\", \"w\", stdout);\r\n-\r\n-    int n,m;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> kruskal_mst = kruskalMST(adj,n,m);\r\n-\r\n-    cout<<\"Kruskal's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n-\r\n-    \r\n-    for(int i = 0; i < kruskal_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = kruskal_mst[i].first;\r\n-        v = kruskal_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686148948408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,9 +73,10 @@\n     //print(adj,n);\r\n \r\n     vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n \r\n-    cout<<\"Prim's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,start)<<endl;\r\n+    cout<<\"Prim's Algorithm:\\n\r\n+    Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n \r\n     for(int i = 0; i < prim_mst.size(); ++i){\r\n         int u,v,w;\r\n         u = prim_mst[i].first;\r\n"
                },
                {
                    "date": 1686148954139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\n\r\n+    cout\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686148959579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\n\";\r\n+    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686148964763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,89 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\n\";\r\n+    cout<<\"\"\r\n+    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686148973293,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,9 +74,9 @@\n \r\n     vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n \r\n     cout<<\"Prim's Algorithm:\\n\";\r\n-    cout<<\"\"\r\n+    cout<<\"Root node = \"<<start<<endl;\r\n     cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n \r\n     for(int i = 0; i < prim_mst.size(); ++i){\r\n         int u,v,w;\r\n@@ -85,269 +85,5 @@\n         cout<<u<<\" \"<<v<<endl; \r\n     }\r\n \r\n     delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\n\";\r\n-    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\n\r\n-    cout\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\n\r\n-    Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686148985533,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,8 +70,9 @@\n         addEdge(adj,v,u,w);\r\n     }\r\n     cin >> start;\r\n     //print(adj,n);\r\n+    i\r\n \r\n     vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n \r\n     cout<<\"Prim's Algorithm:\\n\";\r\n"
                },
                {
                    "date": 1686148995052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,90 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+    if(start>=)\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\n\";\r\n+    cout<<\"Root node = \"<<start<<endl;\r\n+    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686149001378,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,90 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+    if(start<0 )\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\n\";\r\n+    cout<<\"Root node = \"<<start<<endl;\r\n+    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686149007163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,90 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+    if(start<0 || start>= )\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\n\";\r\n+    cout<<\"Root node = \"<<start<<endl;\r\n+    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686149015264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,102 +70,14 @@\n         addEdge(adj,v,u,w);\r\n     }\r\n     cin >> start;\r\n     //print(adj,n);\r\n-    if(start<0 || start>= )\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\n\";\r\n-    cout<<\"Root node = \"<<start<<endl;\r\n-    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n+    if(start<0 || start>=n){\r\n+        cout\r\n     }\r\n \r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n-    double cost = 0.0;\r\n     vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n \r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-    if(start<0 )\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n     cout<<\"Prim's Algorithm:\\n\";\r\n     cout<<\"Root node = \"<<start<<endl;\r\n     cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n \r\n@@ -176,185 +88,5 @@\n         cout<<u<<\" \"<<v<<endl; \r\n     }\r\n \r\n     delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-    if(start>=)\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\n\";\r\n-    cout<<\"Root node = \"<<start<<endl;\r\n-    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-    i\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\n\";\r\n-    cout<<\"Root node = \"<<start<<endl;\r\n-    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686149021880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,92 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+    if(start<0 || start>=n){\r\n+        cout<<\"\"\r\n+    }\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\n\";\r\n+    cout<<\"Root node = \"<<start<<endl;\r\n+    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686149029297,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,92 @@\n+#include<bits/stdc++.h>\r\n+#include\"DisjointSet.h\"\r\n+#include\"GraphUtil.h\"\r\n+using namespace std;\r\n+\r\n+vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n+    vector<pair<int,pair<int,double>>> mst;\r\n+    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n+\r\n+    vector<double> keys(n,INFINITY);\r\n+    vector<int> parents(n,-1);\r\n+    vector<int> vis(n,0);\r\n+\r\n+    keys[start] = 0;\r\n+    minHeap.push({0,start});\r\n+\r\n+    while(!minHeap.empty()){\r\n+        int u = minHeap.top().second;\r\n+        minHeap.pop();\r\n+\r\n+        if(vis[u] == 0){\r\n+\r\n+            vector<pair<int,double>> :: iterator itr;\r\n+            vis[u] = 1;\r\n+\r\n+            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n+                int v = itr->first;\r\n+                double weight = itr->second;\r\n+\r\n+                if(vis[v] == 0 && keys[v] > weight){\r\n+                    parents[v] = u;\r\n+                    keys[v] = weight;\r\n+                    minHeap.push({keys[v],v});\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    for(int i=0;i<n;i++){\r\n+        if(parents[i] != -1){\r\n+            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n+        }\r\n+    }\r\n+    return mst;\r\n+}\r\n+\r\n+double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n+    double cost = 0.0;\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n+    return cost;\r\n+}\r\n+\r\n+int main()\r\n+{\r\n+    freopen(\"in.txt\", \"r\", stdin);\r\n+    freopen(\"prim.txt\", \"w\", stdout);\r\n+\r\n+    int n,m,start;\r\n+    cin >> n >> m;\r\n+\r\n+    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n+\r\n+    for (int i = 0; i < m; ++i){\r\n+        int u,v;\r\n+        double w;\r\n+        cin >> u >> v >> w;\r\n+        addEdge(adj,u,v,w);\r\n+        addEdge(adj,v,u,w);\r\n+    }\r\n+    cin >> start;\r\n+    //print(adj,n);\r\n+    if(start<0 || start>=n){\r\n+        cout<<\"Invalid start \"\r\n+    }\r\n+\r\n+    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n+\r\n+    cout<<\"Prim's Algorithm:\\n\";\r\n+    cout<<\"Root node = \"<<start<<endl;\r\n+    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n+\r\n+    for(int i = 0; i < prim_mst.size(); ++i){\r\n+        int u,v,w;\r\n+        u = prim_mst[i].first;\r\n+        v = prim_mst[i].second.first;\r\n+        cout<<u<<\" \"<<v<<endl; \r\n+    }\r\n+\r\n+    delete[] adj;\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686149044419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,9 @@\n     }\r\n     cin >> start;\r\n     //print(adj,n);\r\n     if(start<0 || start>=n){\r\n-        cout<<\"Invalid start \"\r\n+        cout<<\"Invalid root node.Using 0 as default.\"<<endl;\r\n     }\r\n \r\n     vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n \r\n@@ -88,189 +88,5 @@\n         cout<<u<<\" \"<<v<<endl; \r\n     }\r\n \r\n     delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-    if(start<0 || start>=n){\r\n-        cout<<\"\"\r\n-    }\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\n\";\r\n-    cout<<\"Root node = \"<<start<<endl;\r\n-    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n-}\n-#include<bits/stdc++.h>\r\n-#include\"DisjointSet.h\"\r\n-#include\"GraphUtil.h\"\r\n-using namespace std;\r\n-\r\n-vector<pair<int,pair<int,double>>> primMST(vector<pair<int,double>> adj[],int n,int start){\r\n-    vector<pair<int,pair<int,double>>> mst;\r\n-    priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> minHeap;\r\n-\r\n-    vector<double> keys(n,INFINITY);\r\n-    vector<int> parents(n,-1);\r\n-    vector<int> vis(n,0);\r\n-\r\n-    keys[start] = 0;\r\n-    minHeap.push({0,start});\r\n-\r\n-    while(!minHeap.empty()){\r\n-        int u = minHeap.top().second;\r\n-        minHeap.pop();\r\n-\r\n-        if(vis[u] == 0){\r\n-\r\n-            vector<pair<int,double>> :: iterator itr;\r\n-            vis[u] = 1;\r\n-\r\n-            for(itr=adj[u].begin();itr!=adj[u].end();itr++){\r\n-                int v = itr->first;\r\n-                double weight = itr->second;\r\n-\r\n-                if(vis[v] == 0 && keys[v] > weight){\r\n-                    parents[v] = u;\r\n-                    keys[v] = weight;\r\n-                    minHeap.push({keys[v],v});\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    for(int i=0;i<n;i++){\r\n-        if(parents[i] != -1){\r\n-            mst.push_back({parents[i],{i,edgeWeight(adj,parents[i],i)}});\r\n-        }\r\n-    }\r\n-    return mst;\r\n-}\r\n-\r\n-double mstCost(vector<pair<int,double>> adj[],int n,int start){\r\n-    double cost = 0.0;\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i)cost+=prim_mst[i].second.second;\r\n-    return cost;\r\n-}\r\n-\r\n-int main()\r\n-{\r\n-    freopen(\"in.txt\", \"r\", stdin);\r\n-    freopen(\"prim.txt\", \"w\", stdout);\r\n-\r\n-    int n,m,start;\r\n-    cin >> n >> m;\r\n-\r\n-    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n-\r\n-    for (int i = 0; i < m; ++i){\r\n-        int u,v;\r\n-        double w;\r\n-        cin >> u >> v >> w;\r\n-        addEdge(adj,u,v,w);\r\n-        addEdge(adj,v,u,w);\r\n-    }\r\n-    cin >> start;\r\n-    //print(adj,n);\r\n-    if(start<0 || start>=n){\r\n-        cout\r\n-    }\r\n-\r\n-    vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n-\r\n-    cout<<\"Prim's Algorithm:\\n\";\r\n-    cout<<\"Root node = \"<<start<<endl;\r\n-    cout<<\"Total weight = \"<<mstCost(adj,n,start)<<endl;\r\n-\r\n-    for(int i = 0; i < prim_mst.size(); ++i){\r\n-        int u,v,w;\r\n-        u = prim_mst[i].first;\r\n-        v = prim_mst[i].second.first;\r\n-        cout<<u<<\" \"<<v<<endl; \r\n-    }\r\n-\r\n-    delete[] adj;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686149056738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,8 +72,9 @@\n     cin >> start;\r\n     //print(adj,n);\r\n     if(start<0 || start>=n){\r\n         cout<<\"Invalid root node.Using 0 as default.\"<<endl;\r\n+        start=0;\r\n     }\r\n \r\n     vector<pair<int,pair<int,double>>> prim_mst = primMST(adj,n,start);\r\n \r\n"
                }
            ],
            "date": 1686144939783,
            "name": "Commit-0",
            "content": "#include<bits/stdc++.h>\r\n#include\"DisjointSet.h\"\r\n#include\"GraphUtil.h\"\r\nusing namespace std;\r\n\r\nvector<pair<int,pair<int,double>>> kruskalMST(vector<pair<int,double>> adj[],int n,int e){\r\n    vector<pair<int,pair<int,double>>> mst;\r\n    DisjointSet set(n);\r\n\r\n    vector<pair<double, pair<int, int>>> edges(e);\r\n    for (int i = 0; i < n; i++) {\r\n        for (auto edge : adj[i])edges.push_back({edge.second,{i, edge.first}});\r\n    }\r\n    \r\n    sort(edges.begin(),edges.end());\r\n\r\n    for(auto e:edges){\r\n        int u = e.second.first;\r\n        int v = e.second.second;\r\n        if (set.findUp(u) != set.findUp(v)) {\r\n            mst.push_back({u, {v, e.first}});\r\n            set.Union(u, v);\r\n        }\r\n    }\r\n\r\n    return mst;\r\n}\r\n\r\ndouble mstCost(vector<pair<int,double>> adj[],int n,int e){\r\n    double cost = 0.0;\r\n    vector<pair<int,pair<int,double>>> kruskal_mst = kruskalMST(adj,n,e);\r\n\r\n    for(int i = 0; i < kruskal_mst.size(); ++i)cost+=kruskal_mst[i].second.second;\r\n    return cost;\r\n}\r\n\r\nint main()\r\n{\r\n    freopen(\"in.txt\", \"r\", stdin);\r\n    freopen(\"kruskal.txt\", \"w\", stdout);\r\n\r\n    int n,m;\r\n    cin >> n >> m;\r\n\r\n    vector<pair<int,double>> *adj = new vector<pair<int,double>>[n];\r\n\r\n    for (int i = 0; i < m; ++i){\r\n        int u,v;\r\n        double w;\r\n        cin >> u >> v >> w;\r\n        addEdge(adj,u,v,w);\r\n        addEdge(adj,v,u,w);\r\n    }\r\n    //print(adj,n);\r\n\r\n    vector<pair<int,pair<int,double>>> kruskal_mst = kruskalMST(adj,n,m);\r\n\r\n    cout<<\"Kruskal's Algorithm:\\nTotal weight = \"<<mstCost(adj,n,m)<<endl;\r\n\r\n    \r\n    for(int i = 0; i < kruskal_mst.size(); ++i){\r\n        int u,v,w;\r\n        u = kruskal_mst[i].first;\r\n        v = kruskal_mst[i].second.first;\r\n        cout<<u<<\" \"<<v<<endl; \r\n    }\r\n\r\n    delete[] adj;\r\n}"
        }
    ]
}